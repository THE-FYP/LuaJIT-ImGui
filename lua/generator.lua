----utility functions
local function save_data(filename,...)
    local file,err = io.open(filename,"w")
    if not file then error(err) end
    for i=1, select('#', ...) do
        local data = select(i, ...)
        file:write(data)
    end
    file:close()
end
----------------------------------------
local function  read_data(filename)
    local hfile,err = io.open(filename,"r")
    if not hfile then error(err) end
    local hstrfile = hfile:read"*a"
    hfile:close()
    return hstrfile
end

--iterates lines from a gcc -E in a specific location
local function location(file,locpathT)
    local location_re = '^# (%d+) "([^"]*)"'
    local path_reT = {}
    for i,locpath in ipairs(locpathT) do
        table.insert(path_reT,'^(.*[\\/])('..locpath..')%.h$')
    end
    local in_location = false
    local which_location = ""
	local loc_num
	local loc_num_incr
	local lineold = "" 
	local which_locationold,loc_num_realold
	local lastdumped = false
    local function location_it()
        repeat
            local line = file:read"*l"
            if not line then
				if not lastdumped then
					lastdumped = true
					return lineold, which_locationold,loc_num_realold
				else
					return nil
				end
			end
            if line:sub(1,1) == "#" then
                -- Is this a location pragma?
                local loc_num_t,location_match = line:match(location_re)
                if location_match then
                    in_location = false
                    for i,path_re in ipairs(path_reT) do
                        if location_match:match(path_re) then 
                            in_location = true;
							loc_num = loc_num_t
							loc_num_incr = 0
                            which_location = locpathT[i]
                            break 
                        end
                    end
                end
            elseif in_location then
				local loc_num_real = loc_num + loc_num_incr
				loc_num_incr = loc_num_incr + 1
				if loc_num_realold and loc_num_realold < loc_num_real then
					--old line complete
					local lineR,which_locationR,loc_num_realR = lineold, which_locationold,loc_num_realold
					lineold, which_locationold,loc_num_realold = line,which_location,loc_num_real
					return lineR,which_locationR,loc_num_realR
				else
					lineold=lineold..line
					which_locationold,loc_num_realold = which_location,loc_num_real
                --return line,loc_num_real, which_location
				end
            end
        until false
    end
    return location_it
end
local struct_re = "^%s*struct%s+([^%s;]+);$"
--------------------------------------------------------
--first cimgui
print"get cimgui cdefs"
local pipe,err = io.popen([[gcc -E -DCIMGUI_DEFINE_ENUMS_AND_STRUCTS ../cimgui/cimgui.h]],"r")
if not pipe then error("could not execute gcc "..err) end

local cdefs = {}
for line in location(pipe,{"cimgui"}) do
	line = line:gsub("extern __attribute__%(%(dllexport%)%)%s*","")
	line = line:gsub("extern __declspec%(dllexport%)%s*","")
	if line~="" then table.insert(cdefs,line) end
	
	--local stname = line:match(struct_re)
	--if ADD_TYPEDEF and stname then table.insert(cdefs,"typedef struct "..stname.." "..stname..";\n") end
end

pipe:close()

-- <cdefs_base> <cdefs_out> <imgui_base> <imgui_out>
local args = {...}
assert(args[1] and args[2] and args[3] and args[4])

----- create imgui/cdefs.lua
print("save", args[2])
local ini_cdef = "--[[ BEGIN AUTOGENERATED SEGMENT ]]\nlocal cdecl = [[\n"
local str_cdefs = table.concat(cdefs,"\n")
local hstrfile = read_data(args[1])
save_data(args[2], ini_cdef, str_cdefs, "\n]]\n--[[ END AUTOGENERATED SEGMENT ]]\n", hstrfile)

----- generate imgui/glfw.lua
print("save", args[4])
local classes = require"class_gen"
local base = read_data(args[3])
save_data(args[4], base, classes)

print"-----------------------------done generation"